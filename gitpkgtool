#! /usr/bin/perl

# gitpkgtool by shahada AT abubakar.net
# 
# Copyright (C) 2011, Shahada Abubakar
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# For the latest source, see http://home.abubakar.net/pubdocs

use strict;
use Getopt::Long;
use Cwd;
use File::Basename;
use POSIX;

my $helpflag = 0;
my $debug = 0;

# process command line arguments

if (scalar (@ARGV) ==0 || $ARGV[0] eq 'help' || $ARGV[0] eq '--help') {
	print STDERR 	"\nUsage: gitpkgtool <command> [--options]\n".
								"\n".
								"Commands:\n".
								"  nexttag\n".
								"  - tags the next build number\n".
								"  buildrpm\n".
								"  - builds rpm package file\n".
								"  builddeb\n".
								"  - builds deb package file\n".
								"\n".
								"run \"gitpkgtool <command> --help\" for further options\n\n";

	exit (0);
}

elsif ($ARGV[0] eq 'nexttag') {
	nexttag ();
}

elsif ($ARGV[0] eq 'buildrpm') {
	buildrpm ();
}

elsif ($ARGV[0] eq 'builddeb') {
	builddeb ();
} else {
	print STDERR "Unknown command \"" . $ARGV[0] . "\"\n";
};


exit (0);


# ========================================================================
# tags the last commit with a build tag. The build tag number is 
# incremented from the highest, last, tag number.
# ------------------------------------------------------------------------

sub nexttag {

	shift @ARGV;

	my $verbose = 0;
	my $dontpush = 0;

	my ($opt) = GetOptions (
		'help'		=> \$helpflag,
		'verbose' => \$verbose,
		'debug'		=> \$debug,
		'dontpush'	=> 	\$dontpush
	);

	if (!$opt || $helpflag) {
		print STDERR 
			"\ngitpkgtool nexttag [--dontpush] [--verbose] [--debug]\n".
			"\ntags the current repo with a sequence in the form Bnnnn\n\n";
		exit (1);
	};

	my $nowver = 0;
	open (F, "git tag|");
	while ( my $line = <F>) {
		if (my ($ver) = $line =~ /^B(\d+)$/) {
			if ($ver > $nowver) {
				$nowver = $ver;
			};
		};
	};

	my $nextver = $nowver + 1;
	printf "%sTagging as B$nextver\n",
		($verbose ? "Latest is B$nowver, " : "");
	call_system ("git tag -a -m \"build B$nextver\" B$nextver");

	if (! $dontpush) {
		call_system ("git push --tags");
	};

};


# ========================================================================
# build rpm
# ------------------------------------------------------------------------

sub buildrpm {

	shift @ARGV;

	my $verbose = 0;
	my $scp;

	my ($opt) = GetOptions (
		'help'	=> \$helpflag,
		'verbose' => \$verbose,
		'debug' => \$debug,
		'scp=s' => \$scp
	);

	if (!$opt || $helpflag) {
		print STDERR 
			"\ngitpkgtool buildrpm [--options] <tag> [source]\n".
			"\nOptions:\n".
			"  --verbose - emits running commentary\n".
			"  --debug - show details of external commands\n".
			"  --scp <dir> - scp the RPMS to <dir>\n";
		exit (1);
	};


	my ($buildtag, $reposource) = @ARGV;

	# prepare RPM build area

	$verbose && print STDERR " * Preparing RPM build area\n";
	$debug && print STDERR "   Writing " . $ENV{'HOME'}."/.rpmmacros\n";
	open (F, "> " . $ENV{'HOME'} . "/.rpmmacros") || 
		die "Failed to open " . $ENV{'HOME'} . "/.rpmmacros for writing.\n";
	print F "%_topdir " . $ENV{'HOME'} . "/rpm\n";
	print F "%_tmppath " . $ENV{'HOME'} . "/rpm/tmp\n";
	# %distribution RedHat Linux 9
	# %vendor RedHat
	close (F);

	$debug && print STDERR "   Writing " . $ENV{'HOME'}."/.rpmrc\n";
	open (F, "> " . $ENV{'HOME'} . "/.rpmrc") ||
		die "Failed to open " . $ENV{'HOME'} . "/.rpmrc for writing.\n";
	print F "buildarchtranslate: i386: i386\n";
	print F "buildarchtranslate: i486: i386\n";
	print F "buildarchtranslate: i586: i386\n";
	print F "buildarchtranslate: i686: i386\n";
	print F "buildarchtranslate: athlon: i386\n";
	close (F);

	foreach my $d (
		$ENV{'HOME'} . "/rpm",
		$ENV{'HOME'} . "/rpm/BUILD",
		$ENV{'HOME'} . "/rpm/RPMS",
		$ENV{'HOME'} . "/rpm/RPMS/athlon",
		$ENV{'HOME'} . "/rpm/RPMS/i386",
		$ENV{'HOME'} . "/rpm/RPMS/i486",
		$ENV{'HOME'} . "/rpm/RPMS/i586",
		$ENV{'HOME'} . "/rpm/RPMS/i686",
		$ENV{'HOME'} . "/rpm/RPMS/noarch",
		$ENV{'HOME'} . "/rpm/SOURCES",
		$ENV{'HOME'} . "/rpm/SPECS",
		$ENV{'HOME'} . "/rpm/SRPMS",
		$ENV{'HOME'} . "/rpm/tmp",
		$ENV{'HOME'} . "/rpm/git",
	) {
		$debug && print STDERR "   Creating folder $d\n";
		call_system ("rm -rf $d");
		mkdir $d || die "Failed to mkdir $d\n";
	};


	my $dir = ".";
	my $project = "";

	if (defined $reposource) {
		
		# user specified a repo to pull frm
		$dir = $ENV{'HOME'} . "/rpm/git";
		$verbose && print STDERR " * Cloning $reposource to $dir\n";

		mkdir $dir;
		chdir $dir;

		# clone the repo
		my $ret = call_system ("git clone -q $reposource") &&
			die "\"git clone $reposource\" failed.";

		# we need the name of the project
		opendir (DH, $dir);
		while ( my $fn = readdir (DH)) {
			if ($fn !~ /^\./) {
				$project = $fn;
			};
		};
		closedir (DH);
		chdir ($dir . "/" . $project) ||
			die "Failed to chdir to $dir/$project\n";

	} else {

		# use source in current directory.
		my $nowdir = cwd;
		$verbose && print STDERR " * Using source in $nowdir\n";

		$project = basename ($nowdir);
	};

	# Checkout the specified build
	if ($buildtag ne '') {
		$verbose && print STDERR " * Checking out build $buildtag\n";
		call_system ("git checkout -q $buildtag");
	};

	$verbose && print STDERR " * Cleaning project source $project\n";

	# if it has a makefile, call "make distclean"
	if ( -e "Makefile" || -e "makefile" ) {
		call_system ("make distclean 2>&1 > /dev/null");
	};

	# if it's Eclipse, look for Release* and Debug* subdirectories.
	opendir (DH, ".");
	while (my $fn = readdir (DH)) {
		if ( ($fn =~ /^Release/ && -d $fn) ||
		     ($fn =~ /^Debug/ && -d $fn) ) {
			chdir ($fn);
			call_system ("make clean 2>&1 > /dev/null");
			chdir ("..");
		};
	};

	# get the current git version from "git describe"
	open (F, "git describe|") || die "Unable to pipe from \"git describe\"";
	$buildtag = <F>;
	close (F);
	chomp $buildtag;
	if ($buildtag eq '') {
		die ("source is not tagged properly, unable to build.\n");
	};

	# work up a version number
	my $version = buildToVersion ($buildtag);
	$verbose && print STDERR " * building $buildtag as version $version\n";

	# build the SOURCE tar file
	my $tarfile = $ENV{'HOME'} . "/rpm/SOURCES/$project-$version.tar.gz";
	call_system ("tar c" . ($debug ? "v":"") . "zf $tarfile --exclude ".
		"$project.spec --exclude ./.git --transform ".
		"\"s#^#$project-$version/#\" *") && 
		die "Failed to build $tarfile\n";
	$verbose && print STDERR " * source tarball is in $tarfile\n";

	# copy the SPEC file over, setting version numbers.
	my $specfile = $ENV{'HOME'} . "/rpm/SPECS/$project.spec";
	open (FO, "> $specfile");

	# parse through specfile
	open (FI, "$project.spec") || die "There is no $project.spec file in ".
		"the source.\n";
	while (my $line = <FI>) {
		# replace version number
		if ($line =~ /^Version:/) {
			$line = "Version: $version\n";
		};
		if ($line =~ /^Source:/) {
			$line = "Source: $project-$version.tar.gz\n";
		};

		if ($line =~ /^%changelog/) {

			# generate changelog from git log

			print FO "%changelog\n";
			my $lastauthor = "";
			open (FC, "git log |");
			while (my $line = <FC>) {
				chomp ($line);
				if ($line =~ /^commit/) { next; };
				if ($line =~ /^Merge:/) { next; };
				if ($line =~ /^Author:\s(.*)$/) {
					$lastauthor = $1;
					next;
				};
				if ($line =~ /^Date:\s+(\w+)\s+(\w+)\s+(\w+)\s+[\w:]+\s(\d+)\s/) {
					print FO "\n * $1 $2 $3 $4 $lastauthor\n";
					next;
				};
				if ($line =~ /^\s*$/) {
					next;
				};
				$line =~ s/^\s+//;
				print FO " - $line\n";
			};
			close (FC);
			next;
		};

		# pass through other spec file lines
		print FO $line;
	};
	close (FI);

	close (FO);
	$verbose && print STDERR " * RPM SPEC is in $specfile\n";

	# invoke rpmbuild
	$verbose && print STDERR " * Invoking rpmbuild ...\n";
	call_system ("rpmbuild -ba " . ($debug ? "": "--quiet ") . "$specfile") &&
		die ("rpmbuild of $project.spec failed.\n");

	# scp
	my $findcmd = "find " . $ENV{'HOME'} . "/rpm -type f -name \*.rpm";
	if ($scp) {
		my $filelist;
		open (F, "$findcmd |");
		while (my $line = <F>) {
			chomp $line;
			$filelist .= $line . " ";
		};
		my $scpcmd = "scp " . ($debug ? " " : "-q ") . "$filelist $scp";
		$verbose && print STDERR " * scp'ing files to $scp\n";
		call_system ($scpcmd);
	};
	
	# list output 
	$verbose && print STDERR " * Output:\n\n";
	call_system ($findcmd);
	$verbose && print STDERR "\n\n";



};



# ========================================================================


sub call_system { 

	my ($cmd) = @_;

	$debug && print STDERR "   Exec \"$cmd\"\n";
	system ($cmd);
	if ($? == -1) {
		die ("Failed to execute \"$cmd\"\n");
	}
	elsif ( $? & 127) {
		die ("   Child \"$cmd\" died with signal %d, %s coredump\n",
			($? & 127),  ($? & 128) ? 'with' : 'without'
		);
	}
	else {
		$debug && printf "   Child \"$cmd\" exited with %d\n", $? >> 8;
	};

	return $? >> 8;

};



# ========================================================================
# Convert a build number, which may be something like B1234, or,if not
# committed, like this: build-162-3-g1f2bc39, into something like this:
# x.yyyypzzz.
# ------------------------------------------------------------------------

sub buildToVersion {

	my ($build) = @_;

	if (my ($a, $b, $c) = $build =~ /^B(\d+)-(\d+)-(.*+)$/) {
		return "${a}.${b}.${c}";
	} 
	elsif (my ($a) = $build =~ /^B(\d+)$/) {
		return "${a}";
	} 
	else {
		die "Unable to convert $build to a version number\n";
	};

}


# ========================================================================
# build deb
# ------------------------------------------------------------------------


sub builddeb {

	shift @ARGV;

	my $verbose = 0;
	my $scp;

	my ($opt) = GetOptions (
		'help'	=> \$helpflag,
		'verbose' => \$verbose,
		'debug' => \$debug,
		'scp=s' => \$scp
	);

	if (!$opt || $helpflag) {
		print STDERR 
			"\ngitpkgtool builddeb [--options] <tag> [source]\n".
			"\nOptions:\n".
			"  --verbose - emits running commentary\n".
			"  --debug - show details of external commands\n".
			"  --scp <dir> - scp the RPMS to <dir>\n";
		exit (1);
	};

	# choose somewhere far away to work in
	$verbose && print STDERR " * Preparing work area " . $ENV{'HOME'}."/deb\n";
	call_system ("rm -rf " . $ENV{'HOME'} . "/deb");
	mkdir $ENV{'HOME'} . "/deb";
	

	my ($buildtag, $reposource) = @ARGV;

	my $dir = ".";
	my $project = "";

	if (defined $reposource) {
		
		# user specified a repo to pull frm
		$dir = $ENV{'HOME'} . "/deb/git";
		$verbose && print STDERR " * Cloning $reposource to $dir\n";

		mkdir $dir;
		chdir $dir;

		# clone the repo
		my $ret = call_system ("git clone -q $reposource") &&
			die "\"git clone $reposource\" failed.";

		# we need the name of the project
		opendir (DH, $dir);
		while ( my $fn = readdir (DH)) {
			if ($fn !~ /^\./) {
				$project = $fn;
			};
		};
		closedir (DH);
		chdir ($dir . "/" . $project) ||
			die "Failed to chdir to $dir/$project\n";

	} else {

		# use source in current directory.
		my $nowdir = cwd;
		$verbose && print STDERR " * Using source in $nowdir\n";

		$project = basename ($nowdir);

	};


	# Checkout the specified build
	if ($buildtag ne '') {
		$verbose && print STDERR " * Checking out build $buildtag\n";
		call_system ("git checkout -q $buildtag");
	};

	$verbose && print STDERR " * Cleaning project source $project\n";

	# if it has a makefile, call "make distclean"
	if ( -e "Makefile" || -e "makefile" ) {
		call_system ("make distclean 2>&1 > /dev/null");
	};

	# if it's Eclipse, look for Release* and Debug* subdirectories.
	opendir (DH, ".");
	while (my $fn = readdir (DH)) {
		if ( ($fn =~ /^Release/ && -d $fn) ||
		     ($fn =~ /^Debug/ && -d $fn) ) {
			chdir ($fn);
			call_system ("make clean 2>&1 > /dev/null");
			chdir ("..");
		};
	};

	# get the current git version from "git describe"
	open (F, "git describe|") || die "Unable to pipe from \"git describe\"";
	$buildtag = <F>;
	close (F);
	chomp $buildtag;
	if ($buildtag eq '') {
		die ("source is not tagged properly, unable to build.\n");
	};

	# debianize the project name
	$project = lc $project;
	$project =~ s/_//;
	$verbose && print STDERR " * Debianized project name to $project\n";

	# work up a version number 
	my $version = buildToVersion ($buildtag);

	$verbose && print STDERR " * Building $buildtag as version $version\n";

	# build the SOURCE tar file
	my $tarfile = $ENV{'HOME'} . "/deb/${project}_${version}.orig.tar.gz";
	call_system ("tar c" . ($debug ? "v":"") . "zf $tarfile --exclude ".
		"debian --transform ".
		"\"s#^#$project-$version/#\" *") && 
		die "Failed to build $tarfile\n";
	$verbose && print STDERR " * source tarball is in $tarfile\n";

	# extract back the tarball into the build dir
	$verbose && print STDERR " * extracting tarball to build dir\n";
	call_system ("tar xp". ($debug ? "v" :"") ."fC $tarfile " . 
		$ENV{'HOME'}. "/deb");

	# copy over debian subfolder
	call_system ("cp -a debian " . $ENV{'HOME'}. "/deb/$project-$version/");

	# grep maintainer email from debian/control
	my $maintainer = "nobody\@nobody.org";
	my $controlfile = $ENV{'HOME'} . "/deb/$project-$version/debian/control";
	open (F, $controlfile) || die "Failed to open $controlfile\n";
	while ( my $line = <F>) {
		if ($line =~ /^Maintainer:\s(.*)$/) {
			$maintainer = $1;
		};
	};
	close (F);

	# overwrite a changelog with current version
	my $changelogfile = $ENV{'HOME'} . "/deb/$project-$version/debian/changelog";
	open (F, "> $changelogfile") || die "Failed to open $changelogfile ".
		"for writing\n";
	print F "$project ($version) unstable; urgency=low\n\n";
	print F "  * Release $buildtag via gitpkgtool\n\n";
	print F " -- $maintainer  " . strftime ("%a, %d %b %Y %H:%M:%S %z",
		localtime()) . "\n";
	close (F);

	$verbose && print STDERR " * Building deb source and binary package\n";
	chdir ($ENV{'HOME'} . "/deb/$project-$version");
	call_system ("dpkg-buildpackage");


	# scp
	my $findcmd = "find " . $ENV{'HOME'} . "/deb -maxdepth 1 -type f ".
		"-name \*.deb";
	if ($scp) {
		my $filelist;
		open (F, "$findcmd |");
		while (my $line = <F>) {
			chomp $line;
			$filelist .= $line . " ";
		};
		my $scpcmd = "scp " . ($debug ? " " : "-q ") . "$filelist $scp";
		$verbose && print STDERR " * scp'ing files to $scp\n";
		call_system ($scpcmd);
	};
	
	# list output 
	$verbose && print STDERR " * Output:\n\n";
	call_system ($findcmd);
	$verbose && print STDERR "\n\n";

}

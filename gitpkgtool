#! /usr/bin/perl

# gitpkgtool by shahada AT abubakar.net
# 
# Copyright (C) 2011, Shahada Abubakar
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
# For the latest source, see http://home.abubakar.net/pubdocs

use strict;
use Getopt::Long;
use Cwd;
use File::Basename;
use POSIX;

my $helpflag = 0;
my $debug = 0;

# process command line arguments

if (scalar (@ARGV) ==0 || $ARGV[0] eq 'help' || $ARGV[0] eq '--help') {
	print STDERR 	"\nUsage: gitpkgtool <command> [--options]\n".
								"\n".
								"Commands:\n".
								"  nexttag\n".
								"  - tags the next build number [old style]\n".
								"  nextversion\n".
								"  - tags the next minor version number\n".
								"  nextversionmajor\n".
								"  - tags the next major version number\n".
								"  buildrpm\n".
								"  - builds rpm package file\n".
								"  buildrpmsource\n".
								"  - builds rpm from spec and sources\n".
								"  builddeb\n".
								"  - builds deb package file\n".
								"\n".
								"run \"gitpkgtool <command> --help\" for further options\n\n";

	exit (0);
}

elsif ($ARGV[0] eq 'nexttag') {
	nexttag ();
}

elsif ($ARGV[0] eq 'buildrpm') {
	buildrpm ();
}

elsif ($ARGV[0] eq 'buildrpmsource') {
	buildrpmsource ();
}

elsif ($ARGV[0] eq 'builddeb') {
	builddeb ();
}

elsif ($ARGV[0] eq 'nextversion') {
	nextversion();

} else {
	print STDERR "Unknown command \"" . $ARGV[0] . "\"\n";
};


exit (0);


# ========================================================================
# tags the last commit with a build tag. The build tag number is 
# incremented from the highest, last, tag number.
# ------------------------------------------------------------------------

sub nexttag {

	shift @ARGV;

	my $verbose = 0;
	my $dontpush = 0;

	my ($opt) = GetOptions (
		'help'		=> \$helpflag,
		'verbose' => \$verbose,
		'debug'		=> \$debug,
		'dontpush'	=> 	\$dontpush
	);

	if (!$opt || $helpflag) {
		print STDERR 
			"\ngitpkgtool nexttag [--dontpush] [--verbose] [--debug]\n".
			"\ntags the current repo with a sequence in the form (BRANCH-)nnnn\n\n";
		exit (1);
	};

	# figure out current branch
	open (F, "git branch| grep \"^\\*\\s\"|") || die 
		"Cannot open pipe to git branch";
	my $branch = <F>;
	close (F);
	chomp ($branch);
	$branch =~ s/^\*\s//;
	print "MY branch [$branch]\n";

	# special case
	if ($branch eq 'master') {
		$branch = "B";
	} else {
		$branch .= "-";
	}

	my $nowver = 0;
	open (F, "git tag|");
	while ( my $line = <F>) {
		if (my ($ver) = $line =~ /^${branch}(\d+)$/) {
			print "Found $line";
			if ($ver > $nowver) {
				$nowver = $ver;
			};
		};
	};

	my $nextver = $nowver + 1;
	printf "%sTagging as ${branch}${nextver}\n",
		($verbose ? "Latest is ${branch}${nowver}, " : "");
	call_system ("git tag -a -m \"build ${branch}${nextver}\" ${branch}${nextver}");

	if (! $dontpush) {
		call_system ("git push --tags");
	};

};


# ========================================================================
# nextversion
# tags the next minor version (replaces nexttag)
# ------------------------------------------------------------------------

sub nextversion {

	shift @ARGV;

	my $verbose = 0;
	my $dontpush = 0;

	my ($opt) = GetOptions (
		'help'		=> \$helpflag,
		'verbose' => \$verbose,
		'debug'		=> \$debug,
		'dontpush'	=> 	\$dontpush
	);

	# make sure we are on master branch
	my $branch = getCurrentBranch();
	if ($branch ne 'master') {
		print STDERR "gitpkgtool: Not on master branch, please switch with \"git checkout master\"\n";
		exit (1);
	}

	my ($major, $minor) = getLatestVersion();

	if ($major == 0 && $minor == $0) {
		$major = 1; 
		$minor = 0;
	} else {
		$minor++;
	};

	printf "gitpkgtool: assigning next minor version V${major}-${minor}\n";

	call_system ("git tag -a -m \"Version ${major}-${minor} assigned by gitpkgtool\" V${major}-${minor}");

	print "You probably want to do this now:\n" .
				"  git checkout dev; git merge --no-ff master\n\n";
	
	if (! $dontpush) {
		call_system ("git push --tags");
	};
	exit (0);
}

# ========================================================================
# nextversionmajor
# tags the next major version (replaces nexttag)
# ------------------------------------------------------------------------

sub nextversionmajor {

	shift @ARGV;

	my $verbose = 0;
	my $dontpush = 0;

	my ($opt) = GetOptions (
		'help'		=> \$helpflag,
		'verbose' => \$verbose,
		'debug'		=> \$debug,
		'dontpush'	=> 	\$dontpush
	);

	# make sure we are on master branch
	my $branch = getCurrentBranch();
	if ($branch ne 'master') {
		print STDERR "gitpkgtool: Not on master branch, please switch with \"git checkout master\"\n";
		exit (1);
	}

	my ($major, $minor) = getLatestVersion();

	if ($major == 0 && $minor == $0) {
		$major = 1; 
		$minor = 0;
	} else {
		$major++;
		$minor=0;
	};

	printf "gitpkgtool: assigning next minor version V${major}-${minor}\n";

	call_system ("git tag -a -m \"Version ${major}-${minor} assigned by gitpkgtool\" V${major}-${minor}");

	print "You probably want to do this now:\n" .
				"  git checkout dev; git merge --no-ff master\n\n";
	
	if (! $dontpush) {
		call_system ("git push --tags");
	};
	exit (0);
}

# ========================================================================
# build rpm
# ------------------------------------------------------------------------

sub buildrpm {

	shift @ARGV;

	my $verbose = 0;

	my $pub_cmd = $ENV{'GITPKGTOOL_PUB_CMD'};
	my $pub_dir = $ENV{'GITPKGTOOL_PUB_DIR'};
	my $pub_postexec = $ENV{'GITPKGTOOL_PUB_POSTEXEC'};
	my $pub     = 0;
	my $pubsrc  = 0;

	

	my ($opt) = GetOptions (
		'help'	=> \$helpflag,
		'verbose' => \$verbose,
		'debug' => \$debug,
		'pub_cmd=s' => \$pub_cmd,
		'pub_dir=s' => \$pub_dir,
		'pub_postexec=s' => \$pub_postexec,
		'pub' => \$pub,
		'pubsrc' => \$pubsrc
	);

	if (!$opt || $helpflag) {
		print STDERR 
			"\ngitpkgtool buildrpm [--options] <tag> [source]\n".
			"\nOptions:\n".
			"  --verbose - emits running commentary\n".
			"  --debug - show details of external commands\n".
			"  --pub_cmd - command to exec when publishing\n".
			"  --pub_dir - user\@host:/dir of scp dest for publishing\n".
			"  --pub_postexec - execute command after publishing\n".
			"  --pub     - publish the Binary RPMS\n".
			"  --pubsrc  - publish the Binary & Source RPMS\n";
		exit (1);
	};


	my ($buildtag, $reposource) = @ARGV;

	# prepare RPM build area

	$verbose && print STDERR " * Preparing RPM build area\n";
	$debug && print STDERR "   Writing " . $ENV{'HOME'}."/.rpmmacros\n";
	open (F, "> " . $ENV{'HOME'} . "/.rpmmacros") || 
		die "Failed to open " . $ENV{'HOME'} . "/.rpmmacros for writing.\n";
	print F "%_topdir " . $ENV{'HOME'} . "/rpm\n";
	print F "%_tmppath " . $ENV{'HOME'} . "/rpm/tmp\n";
	# %distribution RedHat Linux 9
	# %vendor RedHat
	close (F);

	$debug && print STDERR "   Writing " . $ENV{'HOME'}."/.rpmrc\n";
	open (F, "> " . $ENV{'HOME'} . "/.rpmrc") ||
		die "Failed to open " . $ENV{'HOME'} . "/.rpmrc for writing.\n";
	print F "buildarchtranslate: i386: i386\n";
	print F "buildarchtranslate: i486: i386\n";
	print F "buildarchtranslate: i586: i386\n";
	print F "buildarchtranslate: i686: i386\n";
	print F "buildarchtranslate: athlon: i386\n";
	close (F);

	foreach my $d (
		$ENV{'HOME'} . "/rpm",
		$ENV{'HOME'} . "/rpm/BUILD",
		$ENV{'HOME'} . "/rpm/RPMS",
		$ENV{'HOME'} . "/rpm/RPMS/athlon",
		$ENV{'HOME'} . "/rpm/RPMS/i386",
		$ENV{'HOME'} . "/rpm/RPMS/i486",
		$ENV{'HOME'} . "/rpm/RPMS/i586",
		$ENV{'HOME'} . "/rpm/RPMS/i686",
		$ENV{'HOME'} . "/rpm/RPMS/noarch",
		$ENV{'HOME'} . "/rpm/SOURCES",
		$ENV{'HOME'} . "/rpm/SPECS",
		$ENV{'HOME'} . "/rpm/SRPMS",
		$ENV{'HOME'} . "/rpm/tmp",
		$ENV{'HOME'} . "/rpm/git",
		$ENV{'HOME'} . "/rpm/tar",
	) {
		$debug && print STDERR "   Creating folder $d\n";
		call_system ("rm -rf $d");
		mkdir $d || die "Failed to mkdir $d\n";
	};


	my $dir = ".";
	my $project = "";

	if (defined $reposource) {
		
		# user specified a repo to pull frm
		$dir = $ENV{'HOME'} . "/rpm/git";
		$verbose && print STDERR " * Cloning $reposource to $dir\n";

		mkdir $dir;
		chdir $dir;

		# clone the repo
		my $ret = call_system ("git clone -q $reposource") &&
			die "\"git clone $reposource\" failed.";

		# we need the name of the project
		opendir (DH, $dir);
		while ( my $fn = readdir (DH)) {
			if ($fn !~ /^\./) {
				$project = $fn;
			};
		};
		closedir (DH);
		chdir ($dir . "/" . $project) ||
			die "Failed to chdir to $dir/$project\n";

	} else {

		# use source in current directory.
		my $nowdir = cwd;
		$verbose && print STDERR " * Using source in $nowdir\n";

		$project = basename ($nowdir);
	};

	# Checkout the specified build
	if ($buildtag ne '') {
		$verbose && print STDERR " * Checking out build $buildtag\n";
		call_system ("git checkout -q $buildtag");
	};

	$verbose && print STDERR " * Cleaning project source $project\n";

	# if it has a makefile, call "make distclean"
	if ( -e "Makefile" || -e "makefile" ) {
		call_system ("make distclean 2>&1 > /dev/null");
	};

	# if it's Eclipse, look for Release* and Debug* subdirectories.
	opendir (DH, ".");
	while (my $fn = readdir (DH)) {
		if ( ($fn =~ /^Release/ && -d $fn) ||
		     ($fn =~ /^Debug/ && -d $fn) ) {
			chdir ($fn);
			call_system ("make clean 2>&1 > /dev/null");
			chdir ("..");
		};
	};

	# get the current git version from "git describe"
	open (F, "git describe|") || die "Unable to pipe from \"git describe\"";
	$buildtag = <F>;
	close (F);
	chomp $buildtag;
	if ($buildtag eq '') {
		die ("source is not tagged properly, unable to build.\n");
	};

	# work up a version number
	my $version = buildToVersion ($buildtag);
	$verbose && print STDERR " * building $buildtag as version $version\n";

	# copy into a folder of $project-$version 
	mkdir $ENV{'HOME'} . "/rpm/tar/$project-$version";
	call_system ("tar czf - --exclude ".
		"./$project.spec --exclude ./.git --exclude ./debian . | tar xpzfC ".
		"- " . $ENV{'HOME'} . "/rpm/tar/$project-$version") &&
		die "Failed to build temporary tarfile";

	# build the SOURCE tar file
	my $tarfile = $ENV{'HOME'} . "/rpm/SOURCES/$project-$version.tar.gz";
	call_system ("tar c" . ($debug ? "v":"") . "zfC $tarfile ".
		$ENV{'HOME'} . "/rpm/tar $project-$version") 
		&& die "Failed to build $tarfile\n";
	$verbose && print STDERR " * source tarball is in $tarfile\n";


	# copy the SPEC file over, setting version numbers and editing
	# other tags on the fly.
	my $specfile = $ENV{'HOME'} . "/rpm/SPECS/$project.spec";
	open (FO, "> $specfile");

	# parse through specfile
	open (FI, "$project.spec") || die "There is no $project.spec file in ".
		"the source.\n";
	while (my $line = <FI>) {
		# replace version number
		if ($line =~ /^Version:/) {
			$line = "Version: $version\n";
		};
		if ($line =~ /^Source:/) {
			$line = "Source: $project-$version.tar.gz\n";
		};

		if ($line =~ /^Name:\s*(.*)\s*/) {
			my $name = $1;
			if ($name =~ /^(.*)\%branch\%/) {
				$name = $1;
				my $branch = getCurrentBranch ();
				if ($branch eq 'master') {
					$branch = '';
				} else {
					$branch = '_' . $branch;
				};
				$line = "Name:${name}${branch}\n";
			};
		};

		if ($line =~ /^%changelog/) {

			# generate changelog from git log

			print FO "%changelog\n";
			my $lastauthor = "";
			open (FC, "git log |");
			while (my $line = <FC>) {
				chomp ($line);
				if ($line =~ /^commit/) { next; };
				if ($line =~ /^Merge:/) { next; };
				if ($line =~ /^Author:\s(.*)$/) {
					$lastauthor = $1;
					next;
				};
				if ($line =~ /^Date:\s+(\w+)\s+(\w+)\s+(\w+)\s+[\w:]+\s(\d+)\s/) {
					print FO "\n * $1 $2 $3 $4 $lastauthor\n";
					next;
				};
				if ($line =~ /^\s*$/) {
					next;
				};
				$line =~ s/^\s+//;
				print FO " - $line\n";
			};
			close (FC);
			next;
		};

		# pass through other spec file lines
		print FO $line;
	};
	close (FI);

	close (FO);
	$verbose && print STDERR " * RPM SPEC is in $specfile\n";

	# invoke rpmbuild
	$verbose && print STDERR " * Invoking rpmbuild ...\n";
	call_system ("rpmbuild -ba " . ($debug ? "": "--quiet ") . "$specfile") &&
		die ("rpmbuild of $project.spec failed.\n");

	# scp
	my $findcmd = "find " . $ENV{'HOME'} . "/rpm -type f -name \*.rpm " .
		($pub ? " ! -name \\*src.rpm" : "");
	if ($pub || $pubsrc) {
		my $filelist;
		open (F, "$findcmd |");
		while (my $line = <F>) {
			chomp $line;
			$filelist .= $line . " ";
		};
		my $pubcmd = $pub_cmd . ' ' . ($debug ? " " : "-q ") . "$filelist ".
			$pub_dir;
		$verbose && print STDERR " * Publishing files ...\n";
		call_system ($pubcmd);

		if (defined $pub_postexec) {
			$verbose && print STDERR " * Executing post-publish script ...\n";
			call_system ($pub_postexec);
		}
	};
	
	# list output 
	$verbose && print STDERR " * Output:\n\n";
	call_system ($findcmd);
	$verbose && print STDERR "\n\n";



};



# ========================================================================


sub call_system { 

	my ($cmd) = @_;

	$debug && print STDERR "   Exec \"$cmd\"\n";
	system ($cmd);
	if ($? == -1) {
		die ("Failed to execute \"$cmd\"\n");
	}
	elsif ( $? & 127) {
		die ("   Child \"$cmd\" died with signal %d, %s coredump\n",
			($? & 127),  ($? & 128) ? 'with' : 'without'
		);
	}
	else {
		$debug && printf "   Child \"$cmd\" exited with %d\n", $? >> 8;
	};

	return $? >> 8;

};



# ========================================================================
# Convert a build number, which may be something like B(count), or
# (branch)-(count).
# If the branch has been committed to since the last tag, then it may
# take the form B(count)-n-hex, or (branch)-(count)-n-hex.
#
# eg: dev-2-1-g14442f4
#
# We need to map this to (count).n.hex(.branch)
# If branch is "B" (master branch) then we can leave it out.
#
# ------------------------------------------------------------------------

sub buildToVersion {

	my ($build) = @_;

	# new style V tags

	if (my ($a) = $build =~ /^V(.*)$/) {
		$a =~ s/-/./g;
		return "${a}";
	}

	# old style B tags
	elsif (my ($a, $b, $c) = $build =~ /^B(\d+)-(\d+)-(.+)$/) {
		return "${a}.${b}.${c}";
	} 
	elsif (my ($a) = $build =~ /^B(\d+)$/) {
		return "${a}";
	} 
	elsif ( my ($a, $b, $c, $d) = $build =~ /^(\w+)-(\d+)-(\d+)-(.+)$/) {
		return "${b}.${c}.${d}.${a}";
	} 
	elsif ( my ($a, $b, $c) = $build =~ /^(\w+)-(\d+)$/) {
		return "${b}.${a}";
	}
	else {
		die "Unable to convert $build to a version number\n";
	};

}


# ========================================================================
# get the current branch name
# ------------------------------------------------------------------------

sub getCurrentBranch {

	# figure out current branch
	open (F, "git branch| grep \"^\\*\\s\"|") || die 
		"Cannot open pipe to git branch";
	my $branch = <F>;
	close (F);
	chomp ($branch);
	$branch =~ s/^\*\s//;

	return $branch;
}


# ========================================================================
# gets latest version number from V{x}-{y} tags.
# ------------------------------------------------------------------------

sub getLatestVersion {

	my $major = 0;
	my $minor = 0;

	# read in all the tags
	open (F, "git tag| grep \"^V\" |") || die "Cannot open pipe to git tag";
	while (my $tagline = <F>) {
		#print "received $tagline\n";
		my ($thisMajor, $thisMinor) = $tagline =~ /V(\d+)-(\d+)/;
		if ($thisMajor > $major) {
			$major = $thisMajor;
		};
		if ($thisMajor == $major &&
		    $thisMinor > $minor) {
			$minor = $thisMinor;
		};
		    
	};
	close (F);
	#print "latest is $major.$minor\n";
	return ($major, $minor);

}


# ========================================================================
# build deb
# ------------------------------------------------------------------------


sub builddeb {

	shift @ARGV;

	my $verbose = 0;

	my $pub_cmd = $ENV{'GITPKGTOOL_PUB_CMD'};
	my $pub_dir = $ENV{'GITPKGTOOL_PUB_DIR'};
	my $pub_postexec = $ENV{'GITPKGTOOL_PUB_POSTEXEC'};
	my $pub     = 0;
	my $pubsrc  = 0;

	my ($opt) = GetOptions (
		'help'	=> \$helpflag,
		'verbose' => \$verbose,
		'debug' => \$debug,
		'pub_cmd=s' => \$pub_cmd,
		'pub_dir=s' => \$pub_dir,
		'pub_postexec=s' => \$pub_postexec,
		'pub' => \$pub,
		'pubsrc' => \$pubsrc
	);

	if (!$opt || $helpflag) {
		print STDERR 
			"\ngitpkgtool builddeb [--options] <tag> [source]\n".
			"\nOptions:\n".
			"  --verbose - emits running commentary\n".
			"  --debug - show details of external commands\n".
			"  --pub_cmd - command to exec when publishing\n".
			"  --pub_dir - user\@host:/dir of ssh dest for publishing\n".
			"  --pub_postexec - execute command after publishing\n".
			"  --pub     - publish the Binary RPMS\n".
			"  --pubsrc  - publish the Binary & Source RPMS\n";
		exit (1);
	};

	# choose somewhere far away to work in
	$verbose && print STDERR " * Preparing work area " . $ENV{'HOME'}."/deb\n";
	call_system ("rm -rf " . $ENV{'HOME'} . "/deb");
	mkdir $ENV{'HOME'} . "/deb";
	

	my ($buildtag, $reposource) = @ARGV;

	my $dir = ".";
	my $project = "";

	if (defined $reposource) {
		
		# user specified a repo to pull frm
		$dir = $ENV{'HOME'} . "/deb/git";
		$verbose && print STDERR " * Cloning $reposource to $dir\n";

		mkdir $dir;
		chdir $dir;

		# clone the repo
		my $ret = call_system ("git clone -q $reposource") &&
			die "\"git clone $reposource\" failed.";

		# we need the name of the project
		opendir (DH, $dir);
		while ( my $fn = readdir (DH)) {
			if ($fn !~ /^\./) {
				$project = $fn;
			};
		};
		closedir (DH);
		chdir ($dir . "/" . $project) ||
			die "Failed to chdir to $dir/$project\n";

	} else {

		# use source in current directory.
		my $nowdir = cwd;
		$verbose && print STDERR " * Using source in $nowdir\n";

		$project = basename ($nowdir);

	};


	# Checkout the specified build
	if ($buildtag ne '') {
		$verbose && print STDERR " * Checking out build $buildtag\n";
		call_system ("git checkout -q $buildtag");
	};

	$verbose && print STDERR " * Cleaning project source $project\n";

	# if it has a makefile, call "make distclean"
	if ( -e "Makefile" || -e "makefile" ) {
		call_system ("make distclean 2>&1 > /dev/null");
	};

	# if it's Eclipse, look for Release* and Debug* subdirectories.
	opendir (DH, ".");
	while (my $fn = readdir (DH)) {
		if ( ($fn =~ /^Release/ && -d $fn) ||
		     ($fn =~ /^Debug/ && -d $fn) ) {
			chdir ($fn);
			call_system ("make clean 2>&1 > /dev/null");
			chdir ("..");
		};
	};

	# get the current git version from "git describe"
	open (F, "git describe|") || die "Unable to pipe from \"git describe\"";
	$buildtag = <F>;
	close (F);
	chomp $buildtag;
	if ($buildtag eq '') {
		die ("source is not tagged properly, unable to build.\n");
	};

	# debianize the project name
	$project = lc $project;
	$project =~ s/_//;
	$verbose && print STDERR " * Debianized project name to $project\n";

	# work up a version number 
	my $version = buildToVersion ($buildtag);

	$verbose && print STDERR " * Building $buildtag as version $version\n";

	# copy into a folder of $project-$version 
	mkdir $ENV{'HOME'} . "/deb/tar";
	mkdir $ENV{'HOME'} . "/deb/tar/$project-$version";
	call_system ("tar czf - --exclude ".
		"./$project.spec --exclude ./.git --exclude ./debian . | tar xpzfC ".
		"- " . $ENV{'HOME'} . "/deb/tar/$project-$version") &&
		die "Failed to build temporary tarfile";

	# build the SOURCE tar file
	my $tarfile = $ENV{'HOME'} . "/deb/${project}_${version}.orig.tar.gz";
	call_system ("tar c" . ($debug ? "v":"") . "zfC $tarfile ".
		$ENV{'HOME'} . "/deb/tar $project-$version") 
		&& die "Failed to build $tarfile\n";
	$verbose && print STDERR " * source tarball is in $tarfile\n";

	# extract back the tarball into the build dir
	$verbose && print STDERR " * extracting tarball to build dir\n";
	call_system ("tar xp". ($debug ? "v" :"") ."fC $tarfile " . 
		$ENV{'HOME'}. "/deb");

	# copy over debian subfolder
	call_system ("cp -a debian " . $ENV{'HOME'}. "/deb/$project-$version/");

	# grep maintainer email from debian/control
	my $maintainer = "nobody\@nobody.org";
	my $controlfile = $ENV{'HOME'} . "/deb/$project-$version/debian/control";
	open (F, $controlfile) || die "Failed to open $controlfile\n";
	while ( my $line = <F>) {
		if ($line =~ /^Maintainer:\s(.*)$/) {
			$maintainer = $1;
		};
	};
	close (F);

	# overwrite a changelog with current version
	my $changelogfile = $ENV{'HOME'} . "/deb/$project-$version/debian/changelog";
	open (F, "> $changelogfile") || die "Failed to open $changelogfile ".
		"for writing\n";
	print F "$project ($version) unstable; urgency=low\n\n";
	print F "  * Release $buildtag via gitpkgtool\n\n";
	print F " -- $maintainer  " . strftime ("%a, %d %b %Y %H:%M:%S %z",
		localtime()) . "\n";
	close (F);

	$verbose && print STDERR " * Building deb source and binary package\n";
	chdir ($ENV{'HOME'} . "/deb/$project-$version");
	call_system ("dpkg-buildpackage");


	# scp
	my $findcmd = "find " . $ENV{'HOME'} . "/deb -maxdepth 1 -type f ".
		"-name \*.deb " . ($pubsrc ? " -o -name \*dsc" : "") ;
	if ($pub || $pubsrc) {
		my $filelist;
		open (F, "$findcmd |");
		while (my $line = <F>) {
			chomp $line;
			$filelist .= $line . " ";
		};
		my $pubcmd = $pub_cmd . ' ' . ($debug ? " " : "-q ") . "$filelist ".
			$pub_dir;
		$verbose && print STDERR " * Publishing files ...\n";
		call_system ($pubcmd);

		if (defined $pub_postexec) {
			$verbose && print STDERR " * Executing post-publish script ...\n";
			call_system ($pub_postexec);
		}
	};
	
	# list output 
	$verbose && print STDERR " * Output:\n\n";
	call_system ($findcmd);
	$verbose && print STDERR "\n\n";

}


# ========================================================================
# buildrpmsource
# ------------------------------------------------------------------------

sub buildrpmsource {

	shift @ARGV;

	my $verbose = 0;

	my $pub_cmd = $ENV{'GITPKGTOOL_PUB_CMD'};
	my $pub_dir = $ENV{'GITPKGTOOL_PUB_DIR'};
	my $pub_postexec = $ENV{'GITPKGTOOL_PUB_POSTEXEC'};
	my $pub     = 0;
	my $pubsrc  = 0;

	my ($opt) = GetOptions (
		'help'	=> \$helpflag,
		'verbose' => \$verbose,
		'debug' => \$debug,
		'pub_cmd=s' => \$pub_cmd,
		'pub_dir=s' => \$pub_dir,
		'pub_postexec=s' => \$pub_postexec,
		'pub' => \$pub,
		'pubsrc' => \$pubsrc
	);

	if (!$opt || $helpflag) {
		print STDERR 
			"\ngitpkgtool buildrpmsource [--options] <tag> [source]\n".
			"\nOptions:\n".
			"  --verbose - emits running commentary\n".
			"  --debug - show details of external commands\n".
			"  --pub_cmd - command to exec when publishing\n".
			"  --pub_dir - user\@host:/dir of scp dest for publishing\n".
			"  --pub_postexec - execute command after publishing\n".
			"  --pub     - publish the Binary RPMS\n".
			"  --pubsrc  - publish the Binary & Source RPMS\n";
		exit (1);
	};


	my ($buildtag, $reposource) = @ARGV;

	# prepare RPM build area

	$verbose && print STDERR " * Preparing RPM build area\n";
	$debug && print STDERR "   Writing " . $ENV{'HOME'}."/.rpmmacros\n";
	open (F, "> " . $ENV{'HOME'} . "/.rpmmacros") || 
		die "Failed to open " . $ENV{'HOME'} . "/.rpmmacros for writing.\n";
	print F "%_topdir " . $ENV{'HOME'} . "/rpm\n";
	print F "%_tmppath " . $ENV{'HOME'} . "/rpm/tmp\n";
	# %distribution RedHat Linux 9
	# %vendor RedHat
	close (F);

	$debug && print STDERR "   Writing " . $ENV{'HOME'}."/.rpmrc\n";
	open (F, "> " . $ENV{'HOME'} . "/.rpmrc") ||
		die "Failed to open " . $ENV{'HOME'} . "/.rpmrc for writing.\n";
	print F "buildarchtranslate: i386: i386\n";
	print F "buildarchtranslate: i486: i386\n";
	print F "buildarchtranslate: i586: i386\n";
	print F "buildarchtranslate: i686: i386\n";
	print F "buildarchtranslate: athlon: i386\n";
	close (F);

	foreach my $d (
		$ENV{'HOME'} . "/rpm",
		$ENV{'HOME'} . "/rpm/BUILD",
		$ENV{'HOME'} . "/rpm/RPMS",
		$ENV{'HOME'} . "/rpm/RPMS/athlon",
		$ENV{'HOME'} . "/rpm/RPMS/i386",
		$ENV{'HOME'} . "/rpm/RPMS/i486",
		$ENV{'HOME'} . "/rpm/RPMS/i586",
		$ENV{'HOME'} . "/rpm/RPMS/i686",
		$ENV{'HOME'} . "/rpm/RPMS/noarch",
		$ENV{'HOME'} . "/rpm/SOURCES",
		$ENV{'HOME'} . "/rpm/SPECS",
		$ENV{'HOME'} . "/rpm/SRPMS",
		$ENV{'HOME'} . "/rpm/tmp",
		$ENV{'HOME'} . "/rpm/git",
		$ENV{'HOME'} . "/rpm/tar",
	) {
		$debug && print STDERR "   Creating folder $d\n";
		call_system ("rm -rf $d");
		mkdir $d || die "Failed to mkdir $d\n";
	};


	my $dir = ".";
	my $project = "";

	if (defined $reposource) {
		
		# user specified a repo to pull frm
		$dir = $ENV{'HOME'} . "/rpm/git";
		$verbose && print STDERR " * Cloning $reposource to $dir\n";

		mkdir $dir;
		chdir $dir;

		# clone the repo
		my $ret = call_system ("git clone -q $reposource") &&
			die "\"git clone $reposource\" failed.";

		# we need the name of the project
		opendir (DH, $dir);
		while ( my $fn = readdir (DH)) {
			if ($fn !~ /^\./) {
				$project = $fn;
			};
		};
		closedir (DH);
		chdir ($dir . "/" . $project) ||
			die "Failed to chdir to $dir/$project\n";

	} else {

		# use source in current directory.
		my $nowdir = cwd;
		$verbose && print STDERR " * Using source in $nowdir\n";

		$project = basename ($nowdir);
	};

	# Checkout the specified build
	if ($buildtag ne '') {
		$verbose && print STDERR " * Checking out build $buildtag\n";
		call_system ("git checkout -q $buildtag");
	};

	# get the current git version from "git describe"
	open (F, "git describe|") || die "Unable to pipe from \"git describe\"";
	$buildtag = <F>;
	close (F);
	chomp $buildtag;
	if ($buildtag eq '') {
		die ("source is not tagged properly, unable to build.\n");
	};

	# work up a version number
	my ($version) = $buildtag =~ /^B(\d)-?/;
	$verbose && print STDERR " * building $buildtag as release $version\n";

	# copy the SPEC file over, setting version numbers.
	my $specfile = $ENV{'HOME'} . "/rpm/SPECS/$project.spec";
	open (FO, "> $specfile");

	# parse through specfile
	open (FI, "$project.spec") || die "There is no $project.spec file in ".
		"the source.\n";
	while (my $line = <FI>) {
		# For "buildrpmsource" the git version is the Release number.
		if ($line =~ /^Release:/) {
			$line = "Release: $version\n";
		};

		if ($line =~ /^%changelog/) {

			# generate changelog from git log

			print FO "%changelog\n";
			my $lastauthor = "";
			open (FC, "git log |");
			while (my $line = <FC>) {
				chomp ($line);
				if ($line =~ /^commit/) { next; };
				if ($line =~ /^Merge:/) { next; };
				if ($line =~ /^Author:\s(.*)$/) {
					$lastauthor = $1;
					next;
				};
				if ($line =~ /^Date:\s+(\w+)\s+(\w+)\s+(\w+)\s+[\w:]+\s(\d+)\s/) {
					print FO "\n * $1 $2 $3 $4 $lastauthor\n";
					next;
				};
				if ($line =~ /^\s*$/) {
					next;
				};
				$line =~ s/^\s+//;
				print FO " - $line\n";
			};
			close (FC);
			next;
		};

		# pass through other spec file lines
		print FO $line;
	};
	close (FI);

	close (FO);
	$verbose && print STDERR " * RPM SPEC is in $specfile\n";

	# Copy all other files to SOURCES
	opendir (DH, ".") || die "Failed to open current directory";
	while (my $file = readdir (DH)) {
		if ($file =~ "^\\." || $file eq "debian" || $file eq "README") {
			next;
		};
		call_system ("/bin/cp " . ($debug ? "-v " : "") . $file . " " .
			$ENV{'HOME'} . "/rpm/SOURCES") && 
			die "Failed to copy $file to /rpm/SOURCES";
	};
	closedir (DH);

	# invoke rpmbuild
	$verbose && print STDERR " * Invoking rpmbuild ...\n";
	call_system ("rpmbuild -ba " . ($debug ? "": "--quiet ") . "$specfile") &&
		die ("rpmbuild of $project.spec failed.\n");

	# scp
	my $findcmd = "find " . $ENV{'HOME'} . "/rpm -type f -name \*.rpm " .
		($pub ? " ! -name \\*src.rpm" : "");
	if ($pub || $pubsrc) {
		my $filelist;
		open (F, "$findcmd |");
		while (my $line = <F>) {
			chomp $line;
			$filelist .= $line . " ";
		};
		my $pubcmd = $pub_cmd . ' ' . ($debug ? " " : "-q ") . "$filelist ".
			$pub_dir;
		$verbose && print STDERR " * Publishing files ...\n";
		call_system ($pubcmd);

		if (defined $pub_postexec) {
			$verbose && print STDERR " * Executing post-publish script ...\n";
			call_system ($pub_postexec);
		}
	};
	
	# list output 
	$verbose && print STDERR " * Output:\n\n";
	call_system ($findcmd);
	$verbose && print STDERR "\n\n";



};
